// backend/controllers/paymentController.js
import stripe from "../../utils/paystackClient.js";
import Payment from "./payment.model.js";
import buildResponse from "../../utils/responseBuilder.js";
import RemitaService from "./remita.service.js";

/**
 * ðŸŽ¯ Create a payment intent (Stripe)
 */
export const createPaymentIntent = async (req, res) => {
  const { amount, feeType, description, provider = "STRIPE" } = req.body;

  try {
    if (!amount || amount <= 0)
      return buildResponse(res, 400, "Invalid amount", null, true);

    const studentId = req.user?._id;
    if (!studentId)
      return buildResponse(res, 401, "Unauthorized: Student not found", null, true);

    // Get student info
    const studentInfo = {
      matricNumber: req.user.matricNumber,
      fullName: `${req.user.firstName} ${req.user.lastName}`,
      email: req.user.email,
      phone: req.user.phone,
      department: req.user.department,
      level: req.user.level,
      session: req.user.session
    };

    // Generate transaction reference
    const transactionRef = Payment.generateTransactionRef();

    // Create payment record
    const paymentData = {
      payer: studentId,
      amount: amount,
      currency: "NGN",
      feeType,
      description: description || `${feeType} payment`,
      provider: provider.toUpperCase(),
      status: "CREATED",
      transactionRef,
      studentInfo,
      academicSession: req.user.session,
      metadata: {
        initiatedBy: studentId,
        userAgent: req.headers["user-agent"],
        ipAddress: req.ip
      }
    };

    const payment = await Payment.create(paymentData);

    // Route to appropriate payment provider
    if (provider.toUpperCase() === "STRIPE") {
      return await processStripePayment(payment, req, res);
    } else if (provider.toUpperCase() === "REMITA") {
      return await processRemitaPayment(payment, req, res);
    } else {
      return buildResponse(res, 400, "Unsupported payment provider", null, true);
    }

  } catch (error) {
    console.error("Create payment intent error:", error);
    return buildResponse(res, 500, "Payment creation failed", null, true);
  }
};

/**
 * Process Stripe payment
 */
async function processStripePayment(payment, req, res) {
  try {
    const amountInKobo = Math.round(payment.amount * 100);

    // Create PaymentIntent on Stripe
    const paymentIntent = await stripe.paymentIntents.create({
      amount: amountInKobo,
      currency: "ngn",
      metadata: { 
        studentId: payment.payer.toString(),
        feeType: payment.feeType,
        transactionRef: payment.transactionRef
      },
      description: payment.description || `${payment.feeType} payment`,
    });

    // Update payment with Stripe details
    payment.providerPaymentId = paymentIntent.id;
    payment.stripe = {
      paymentIntentId: paymentIntent.id,
      clientSecret: paymentIntent.client_secret
    };
    payment.status = paymentIntent.status === "requires_action" ? "REQUIRES_ACTION" : "PENDING";
    
    await payment.save();

    return buildResponse(res, 200, "Stripe payment initialized", {
      clientSecret: paymentIntent.client_secret,
      paymentId: payment._id,
      amount: payment.amount,
      currency: payment.currency,
      transactionRef: payment.transactionRef,
      provider: "STRIPE",
      requiresAction: paymentIntent.status === "requires_action"
    });

  } catch (error) {
    console.error("Stripe payment error:", error);
    payment.status = "FAILED";
    await payment.save();
    
    return buildResponse(res, 500, "Stripe payment failed: " + error.message, null, true);
  }
}

/**
 * Process Remita payment
 */
async function processRemitaPayment(payment, req, res) {
  try {
    const remitaService = new RemitaService();
    const studentData = req.user;

    // Initialize Remita payment
    const remitaResult = await remitaService.initializePayment(payment._id, studentData);

    return buildResponse(res, 200, "Remita payment initialized", {
      paymentId: payment._id,
      amount: payment.amount,
      currency: payment.currency,
      transactionRef: payment.transactionRef,
      provider: "REMITA",
      paymentUrl: remitaResult.paymentUrl,
      environment: remitaResult.environment,
      instructions: {
        web: "You will be redirected to Remita payment page",
        ussd: "Dial *737# for USSD payment",
        bank: "Make transfer to Remita collection account"
      }
    });

  } catch (error) {
    console.error("Remita payment error:", error);
    payment.status = "FAILED";
    await payment.save();
    
    return buildResponse(res, 500, "Remita payment failed: " + error.message, null, true);
  }
}

/**
 * ðŸŽ¯ Get AFUED payment services
 */
export const getAFUEDServices = async (req, res) => {
  try {
    const remitaService = new RemitaService();
    const services = remitaService.getAFUEDServices();

    return buildResponse(res, 200, "AFUED payment services retrieved", {
      university: "Adeyemi Federal University of Education",
      services: Object.values(services),
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error("Get AFUED services error:", error);
    return buildResponse(res, 500, "Failed to retrieve services", null, true);
  }
};

/**
 * ðŸŽ¯ Verify Remita payment
 */
export const verifyRemitaPayment = async (req, res) => {
  try {
    const { transactionRef } = req.params;

    if (!transactionRef) {
      return buildResponse(res, 400, "Transaction reference is required", null, true);
    }

    const remitaService = new RemitaService();
    const verification = await remitaService.verifyPayment(transactionRef);

    return buildResponse(res, 200, "Payment verification completed", verification);

  } catch (error) {
    console.error("Verify Remita payment error:", error);
    return buildResponse(res, 500, "Payment verification failed: " + error.message, null, true);
  }
};

/**
 * ðŸŽ¯ Handle Remita webhook
 */
export const remitaWebhook = async (req, res) => {
  try {
    const webhookData = req.body;
    const signature = req.headers["x-remita-signature"];

    console.log("Received Remita webhook:", {
      data: webhookData,
      signature,
      timestamp: new Date().toISOString()
    });

    // Verify signature (implement based on Remita docs)
    // const isValid = verifySignature(webhookData, signature);
    // if (!isValid) {
    //   return res.status(401).json({ error: "Invalid signature" });
    // }

    const remitaService = new RemitaService();
    const result = await remitaService.handleWebhook(webhookData);

    // Always respond quickly to webhooks
    res.json({
      success: true,
      message: "Webhook processed successfully",
      data: result
    });

  } catch (error) {
    console.error("Remita webhook error:", error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

/**
 * ðŸŽ¯ Get payment by ID
 */
export const getPaymentById = async (req, res) => {
  try {
    const { paymentId } = req.params;
    const studentId = req.user?._id;

    const payment = await Payment.findById(paymentId);
    if (!payment) {
      return buildResponse(res, 404, "Payment not found", null, true);
    }

    // Check authorization (student can only see their own payments)
    if (payment.payer.toString() !== studentId.toString() && 
        !req.user.roles.includes("admin") && 
        !req.user.roles.includes("superuser")) {
      return buildResponse(res, 403, "Unauthorized to view this payment", null, true);
    }

    return buildResponse(res, 200, "Payment retrieved", payment);

  } catch (error) {
    console.error("Get payment by ID error:", error);
    return buildResponse(res, 500, "Failed to retrieve payment", null, true);
  }
};

/**
 * ðŸŽ¯ Get all payments (admin)
 */
export const getAllPayments = async (req, res) => {
  try {
    const { page = 1, limit = 20, status, feeType, provider } = req.query;
    const skip = (page - 1) * limit;

    const filter = {};
    if (status) filter.status = status;
    if (feeType) filter.feeType = feeType;
    if (provider) filter.provider = provider;

    const payments = await Payment.find(filter)
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(parseInt(limit))
      .populate("payer", "firstName lastName email matricNumber");

    const total = await Payment.countDocuments(filter);

    return buildResponse(res, 200, "Payments retrieved", {
      payments,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    console.error("Get all payments error:", error);
    return buildResponse(res, 500, "Failed to retrieve payments", null, true);
  }
};

/**
 * ðŸŽ¯ Get my payments (student)
 */
export const getMyPayments = async (req, res) => {
  try {
    const studentId = req.user?._id;
    const { page = 1, limit = 10, status } = req.query;
    const skip = (page - 1) * limit;

    const filter = { payer: studentId };
    if (status) filter.status = status;

    const payments = await Payment.find(filter)
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(parseInt(limit));

    const total = await Payment.countDocuments(filter);

    return buildResponse(res, 200, "Your payments retrieved", {
      payments,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    console.error("Get my payments error:", error);
    return buildResponse(res, 500, "Failed to retrieve your payments", null, true);
  }
};

// Your existing stripeWebhook function remains the same...